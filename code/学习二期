require.context（检索目录，是否检索子文件夹，文件名匹配的正则表达式）；是一个webpack的api,主要用来实现模块的自动化导入。
这个函数执行后返回一个函数，返回的这个函数有三个属性：id,keys,resolve。resolve是一个函数，它接收一个参数requst
keys,也是一个函数，返回的是匹配成功模块的名字组成的数组。id是字符串，是执行环境的id
token存在cookie中的好处：因为cokie受同源策略的影响所以cookie中存token，只要设置了过期时间即使浏览器关闭也是有效的。

设计模式中的mixin模式：
 通常我们利用原型能实现从一个类到另一个类的继承，这种继承具有父子或者是主从属性。而使用mixins可以让这个继承实现扁平化。
 也就是说mixin是一个包含了可被其他类使用而无需继承的方法的类
 
 vue中的mixin混入
 主要解决：重复性功能。
 使用方法：mixins的语法和一般vue组件一样，该有的methods,computed,mounted都会有。作用就是代替组件中重复的功能。使用方法就是在需要的组件中注册（ mixins: [myMixin]）
 
 createPersistedState:实现数据存储，通常配合vuex使用。因为vuex有一个缺点就是在页面刷新之后数据会消失。
 本质还是web存储数据的那几种方式，默认的存储键名是"vuex",
 
Peomise知识补充
promise本质就是一个延迟回调函数，能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来；这个异步操作会返回一个promise。
一个promise必然会处于三种状态之一：
1.pending：初始状态，没有被兑现，也没有被拒绝
2.fulfilled：操作完成
3.rejected：操作失败
then操作在什么时候会发生：不管是promise处于fulfilled还是rejected 状态下，then方法里面的相关处理程序都会被调用。
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

function MyPromise(executor) {
    let self = this; // 缓存当前promise实例
    self.value = null;
    self.error = null; 
    self.status = PENDING;
    self.onFulfilledCallback = []; //成功的回调函数
    self.onRejectedCallback = []; //失败的回调函数

    const resolve = (value) => {
        if(self.status !== PENDING) return;
        setTimeout(() => {
        self.status = FULFILLED;
        self.value = value;
        self.onFulfilledCallback.forEach((callback)=>callback(self.value));//resolve时执行成功回调
        });
    };

    const reject = (error) => {
        if(self.status !== PENDING) return;
        setTimeout(() => {
        self.status = REJECTED;
        self.error = error;
        // self.onRejected(self.error);//resolve时执行成功回调
        self.onRejectedCallback.forEach((callback)=>callback(self.value));
        });
    };
    executor(resolve, reject);
}
MyPromise.prototype.then = function(onFulfilled, onRejected) {
    if (this.status === PENDING) {
        this.onFulfilledCallback.push(onFulfilled);
        this.onRejectedCallback.push(onRejected);
    } else if (this.status === FULFILLED) {
        //如果状态是fulfilled，直接执行成功回调，并将成功值传入
        onFulfilled(this.value)
    } else {
        //如果状态是rejected，直接执行失败回调，并将失败原因传入
        onRejected(this.error)
    }
    return this;
}

vue的自定义指令：
vue.directives()

算法：有效的括号（结合栈）
const isValid=(s)=>{
    if(!s){
        return true
    }
    //定义一对正确的括号对象
    const leftToRight={
        '(':')',
        '[':']',
        '{':'}'
    }
    const stack=[];
    //循环传入的字符串
    for(let i=0, len=s.length; i<len; i++){
        //分别把每个值赋值给ch
        const ch=s[i];
        //判断传入的参数内，有没有对应关系，如果有就加入stack数组
        if(leftToRight[ch]){
            stack.push(ch);
        }else{
            //如果没有表示需要找寻括号的另一半
            const flag=leftToRight[stack.pop()];
            if(!stack.length||flag!=ch){
                return false;
            }
        }
    }
    return !stack.length
}
isValid('{[(]}}');

可迭代对象：简单来说可迭代对象就是可以被for...of 循环的对象。比如数组、类数组、set结构、map结构
迭代对象自带一个Symbol.iterator方法，当for....of 循环启动的时候会调用这个方法，这个方法会返回一个迭代器（Iterator）
这个Iterator迭代器有一个next（）方法，当for....of循环希望取得下一个值时，就会调用next（）这个方法，
next（)方法返回的结果的格式{done:Boolean,value:any}。当done为true时，表示循环结束。
判断一个对象是否是可迭代对象；isintance()
let range={
    from:1,
    to:5
}
//我们希望for of能执行1，2，3，4，5
//for(let num of range){}
//自定义迭代器方法，需要注意的是：[Symbol.iterator]()是一个函数方法，其中包含了next方法
//range本身通过调用Symbol.iterator方法生成range迭代器对象，这个迭代器对象中包含next方法
range[Symbol.iterator]=function(){
    return {
        current:this.from,
        last:this.to,
        next(){
            if(this.current<=this.last){
                return {done:false,value:this.current++}
            }else{
                return {done:true}
            }
        }
    }
    
}

生成器：Generator写法上是一个带 * 的函数，通过关键字yield暂停执行和恢复执行。
//生成器Generator
function* gen(){
    console.log('enter');
    let a=yield 1;
    let b=yield (function(){return 2})();
    return 3;
}
var g=gen();
//调用next后就往下执行，知道遇到yield停止，所以这里执行完之后就会打印enter,1
console.log(g.next());
console.log(g.next());

call/bind/apply
这三个都是为了改变函数运行时的上下文


